EJERCICIOS - PARTE 1
Realiza los siguientes ejercicios haciendo uso del módulo multiprocessing visto en clase. En todos los casos, realiza un cálculo del tiempo que tardan en ejecutarse.

_____________________________________________________________________________________________________________________________________________
1
Crea una función en Python que sea capaz de sumar todos los números desde el 1 hasta un valor introducido por parámetro, 
 incluyendo ambos valores y mostrar el resultado por pantalla.
 Desde el programa principal crea varios procesos que ejecuten la función anterior. 
 El programa principal debe imprimir un mensaje indicando que todos los procesos han terminado después de que los procesos hayan impreso el resultado.

 ➜ TECNOLOGÍA: Process
 ➜ ESTRUCTURA:
     ┌─────────────────────────────────────┐
     │   Proceso Padre (main)              │
     └─────────────┬───────────────────────┘
                   │
         ┌─────────┼─────────┬─────────────┐
         │         │         │             │
         ▼         ▼         ▼             ▼
     [Worker1] [Worker2] [Worker3] ... [WorkerN]
     suma(1,n) suma(1,n) suma(1,n)     suma(1,n)
         │         │         │             │
         └─────────┴─────────┴─────────────┘
                      │
                  (imprime)
_____________________________________________________________________________________________________________________________________________
2
Modifica el ejercicio anterior para que el programa principal use un Pool para lanzar varios procesos de forma concurrente. 
 Cambia el valor del número de procesos y compara los tiempos que tarda en ejecutarse en los distintos casos.

 ➜ TECNOLOGÍA: Pool + map()
 ➜ ESTRUCTURA:
     ┌─────────────────────────────────────┐
     │   Proceso Padre (main)              │
     │   Pool.map(func, [val1, val2...])   │
     └─────────────┬───────────────────────┘
                   │
         ┌─────────┼─────────┬─────────────┐
         │    Pool gestiona automáticamente │
         ▼         ▼         ▼             ▼
     [Worker1] [Worker2] [Worker3] ... [WorkerN]
     suma(val1) suma(val2) suma(val3)   suma(valN)
         │         │         │             │
         └─────────┴─────────┴─────────────┘
                      │
                  (retorna resultados al Pool → Padre)
_____________________________________________________________________________________________________________________________________________
3
Realiza el ejercicio anterior pero esta vez va a haber otra función que lea los números de un fichero. En el fichero habrá un número por línea.
 En este caso, tienes que llevar a cabo una comunicación entre los dos procesos utilizando colas (Queue), de forma que la función que se encarga
 de leer los números los guarde en la cola, y la función que realiza la suma, recibirá la cola y tomará de ahí los números. 
 La función que lee el fichero, una vez haya terminado de leer y de añadir elementos a la cola, debe añadir un objeto None para que el receptor sepa cuándo terminar de leer de la cola.

 ➜ TECNOLOGÍA: Process + Queue
 ➜ ESTRUCTURA:
     ┌─────────────────┐
     │ Proceso Padre   │
     └────────┬────────┘
              │ crea
         ┌────┴────┐
         │  Queue  │ (compartida)
         └────┬────┘
              │
      ┌───────┴───────┐
      │               │
      ▼               ▼
  [Productor]     [Consumidor]
  lee_fichero     suma_numeros
      │               │
      ├─ put(num1)───→│
      ├─ put(num2)───→│ get() → acumula
      ├─ put(num3)───→│ get() → acumula
      └─ put(None)───→│ get() → FIN
                      │
                   (devuelve resultado al Padre)
_____________________________________________________________________________________________________________________________________________
4
En este caso, vuelve a realizar la comunicación entre procesos pero usando tuberías (Pipe), de forma que la función que se encarga de leer
 los números del fichero se los envíe (send) al proceso que se encarga de la suma. El proceso que suma los números tiene que recibir (recv) 
 un número y realizar la suma. Una vez que el proceso que lee el fichero termine de leer números en el fichero, debe enviar un None. 
 El que recibe números dejará de realizar sumas cuando reciba un None.

 ➜ TECNOLOGÍA: Process + 2 Pipes
 ➜ ESTRUCTURA:
     ┌─────────────────────────────────────┐
     │        Proceso Padre (main)         │
     └───────────────┬─────────────────────┘
                     │ crea 2 Pipes
          ┌──────────┴──────────┐
          │                     │
      [Pipe1]               [Pipe2]
    (datos →)             (← resultados)
          │                     │
          │                     │
      ┌───▼──────────┐    ┌─────▼────────┐
      │  Productor   │    │  Consumidor  │
      │ lee_fichero  │    │ suma_numeros │
      └──────────────┘    └──────────────┘
          │                     │
          ├─ send(num1) ───────→│
          ├─ send(num2) ───────→│ recv() → acumula
          ├─ send(num3) ───────→│ recv() → acumula
          └─ send(None) ───────→│ recv() → FIN
                                │
                         send(resultado) ────→ Padre recv()
_____________________________________________________________________________________________________________________________________________
5
Crea una función en Python que sea capaz de sumar todos los números comprendidos entre dos valores, incluyendo ambos valores 
 y mostrar el resultado por pantalla. 
 Estos valores se les pasará como argumentos. Hay que tener presente que el primer argumento puede ser mayor que el segundo, 
 y habrá que tenerlo presente para realizar la suma.
 Desde el programa principal crea varios procesos que ejecuten la función anterior. El programa principal debe imprimir un mensaje indicando
 que todos los procesos han terminado después de que los procesos hayan impreso el resultado.

 ➜ TECNOLOGÍA: Process
 ➜ ESTRUCTURA:
     ┌─────────────────────────────────────┐
     │   Proceso Padre (main)              │
     └─────────────┬───────────────────────┘
                   │
         ┌─────────┼─────────┬─────────────┐
         │         │         │             │
         ▼         ▼         ▼             ▼
     [Worker1] [Worker2] [Worker3] ... [WorkerN]
     suma(a,b) suma(c,d) suma(e,f)     suma(x,y)
         │         │         │             │
         └─────────┴─────────┴─────────────┘
                      │
                  (imprime)
_____________________________________________________________________________________________________________________________________________
6
Modifica el ejercicio anterior para usar un Pool para lanzar varios procesos de forma concurrente.
 Recuerda que al tener dos argumentos debes usar el método starmap en vez de map.

 ➜ TECNOLOGÍA: Pool + starmap()
 ➜ ESTRUCTURA:
     ┌─────────────────────────────────────────────┐
     │   Proceso Padre (main)                      │
     │   Pool.starmap(func, [(a,b), (c,d)...])     │
     └─────────────┬───────────────────────────────┘
                   │
         ┌─────────┼─────────┬─────────────┐
         │    Pool gestiona automáticamente │
         ▼         ▼         ▼             ▼
     [Worker1] [Worker2] [Worker3] ... [WorkerN]
     suma(a,b) suma(c,d) suma(e,f)     suma(x,y)
         │         │         │             │
         └─────────┴─────────┴─────────────┘
                      │
                  (retorna resultados al Pool → Padre)
_____________________________________________________________________________________________________________________________________________
7
Realiza el ejercicio anterior pero esta vez va a haber otra función que lea los números de un fichero. En el fichero habrá dos números 
 por línea separados por un espacio. En este caso, tienes que llevar a cabo una comunicación entre los dos procesos utilizando colas (Queue), 
 de forma que la función que se encarga de leer los números los guarde en la cola, y la función que realiza la suma, recibirá la cola y tomará de ahí los dos números.

 ➜ TECNOLOGÍA: Process + Queue (múltiples consumidores)
 ➜ ESTRUCTURA:
     ┌─────────────────┐
     │ Proceso Padre   │
     └────────┬────────┘
              │ crea
         ┌────┴────┐
         │  Queue  │ (compartida)
         └────┬────┘
              │
      ┌───────┴───────────────────┐
      │               │           │
      ▼               ▼           ▼
  [Productor]     [Worker1]   [Worker2]
  lee_fichero     suma_rango  suma_rango
      │               │           │
      ├─ put(a,b)────→│           │ get() → suma(a,b)
      ├─ put(c,d)────→│           │ get() → suma(c,d)
      ├─ put(e,f)────→│           │ get() → suma(e,f)
      └─ put(None)───→│           │ get() → FIN
                      │           │
                   (imprime)  (imprime)
_____________________________________________________________________________________________________________________________________________
8
En este caso, vuelve a realizar la comunicación entre procesos pero usando tuberías (Pipe), de forma que la función que se encarga de leer los números 
 del fichero se los envíe (send) al proceso que los suma. El proceso que suma los números tiene que recibir (recv) los dos números y realizar la suma entre ellos.

 ➜ TECNOLOGÍA: Process + 2 Pipes
 ➜ ESTRUCTURA:
     ┌─────────────────────────────────────┐
     │        Proceso Padre (main)         │
     └───────────────┬─────────────────────┘
                     │ crea 2 Pipes
          ┌──────────┴──────────┐
          │                     │
      [Pipe1]               [Pipe2]
    (pares →)             (← resultados)
          │                     │
          │                     │
      ┌───▼──────────┐    ┌─────▼────────┐
      │  Productor   │    │    Worker    │
      │ lee_fichero  │    │ suma_rangos  │
      └──────────────┘    └──────────────┘
          │                     │
          ├─ send(a,b) ────────→│ recv() → suma(a,b)
          ├─ send(c,d) ────────→│ recv() → suma(c,d)
          ├─ send(e,f) ────────→│ recv() → suma(e,f)
          └─ send(None) ───────→│ recv() → FIN
                                │
                        send([resultados]) ──→ Padre recv()
_____________________________________________________________________________________________________________________________________________

ej1, ej5: Múltiples workers independientes
ej2, ej6: Pool gestionando workers automáticamente
ej3, ej7: Queue con productor-consumidor(es)
ej4, ej8: 2 Pipes para comunicación bidireccional (datos → y resultados ←)

ej2, ej6: Pool → Pool maneja el IPC por ti